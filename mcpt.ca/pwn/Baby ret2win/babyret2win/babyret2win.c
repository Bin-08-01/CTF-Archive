#include <stdio.h>

void print_flag(){
    char flag[0x100];
    FILE *fp;
    fp = fopen("flag.txt","r");
    fgets(flag, sizeof(flag), fp);
    puts(flag);
}

int main(){
    setvbuf(stdin, NULL, 2, 0);
    setvbuf(stdout, NULL, 2, 0);
    puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Your next step on this journey to become a master pwner is to conquer a...\n"
" ________   ___  ___   ________  ________  _______    ________   \n"
"|\\   __  \\ |\\  \\|\\  \\ |\\  _____\\|\\  _____\\|\\  ___ \\  |\\   __  \\    \n"
"\\ \\  \\|\\ /_\\ \\  \\\\\\  \\\\ \\  \\__/ \\ \\  \\__/ \\ \\   __/| \\ \\  \\|\\  \\   \n"
" \\ \\   __  \\\\ \\  \\\\\\  \\\\ \\   __\\ \\ \\   __\\ \\ \\  \\_|/__\\ \\   _  _\\  \n"
"  \\ \\  \\|\\  \\\\ \\  \\\\\\  \\\\ \\  \\_|  \\ \\  \\_|  \\ \\  \\_|\\ \\\\ \\  \\\\  \\| \n"
"   \\ \\_______\\\\ \\_______\\\\ \\__\\    \\ \\__\\    \\ \\_______\\\\ \\__\\\\ _\\ \n"
"    \\|_______| \\|_______| \\|__|     \\|__|     \\|_______| \\|__|\\|__|\n"
"\n"
" ________   ___      ___  _______    ________   ________  ___        ________   ___       __      \n"
"|\\   __  \\ |\\  \\    /  /||\\  ___ \\  |\\   __  \\ |\\  _____\\|\\  \\      |\\   __  \\ |\\  \\     |\\  \\    \n"
"\\ \\  \\|\\  \\\\ \\  \\  /  / /\\ \\   __/| \\ \\  \\|\\  \\\\ \\  \\__/ \\ \\  \\     \\ \\  \\|\\  \\\\ \\  \\    \\ \\  \\   \n"
" \\ \\  \\\\\\  \\\\ \\  \\/  / /  \\ \\  \\_|/__\\ \\   _  _\\\\ \\   __\\ \\ \\  \\     \\ \\  \\\\\\  \\\\ \\  \\  __\\ \\  \\  \n"
"  \\ \\  \\\\\\  \\\\ \\    / /    \\ \\  \\_|\\ \\\\ \\  \\\\  \\|\\ \\  \\_|  \\ \\  \\____ \\ \\  \\\\\\  \\\\ \\  \\|\\__\\_\\  \\ \n"
"   \\ \\_______\\\\ \\__/ /      \\ \\_______\\\\ \\__\\\\ _\\ \\ \\__\\    \\ \\_______\\\\ \\_______\\\\ \\____________\\\n"
"    \\|_______| \\|__|/        \\|_______| \\|__|\\|__| \\|__|     \\|_______| \\|_______| \\|____________|\n"
"\n"
"Note: It is recommended to complete `babybof` before this\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Continuing from `babybof`, we'll go into more detail about how variable\n"
"(and other things) are represented internally.\n"
"\n"
"We see the binary is basically the same, except the print_flag function is\n"
"commented out! To figure out how to solve this, let's recall how we\n"
"represented variable internally.\n"
"Variables:\n"
"+--------------------------------+--------+\n"
"|name                            |is_admin|\n"
"+--------------------------------+----+---+\n"
"|????????????????????????????????|0000|\n"
"+--------------------------------+----+\n"
"\n"
"What we did in the last challenge was overwrite `is_admin` to get the flag\n"
"but with the print_flag function commented out, it does not print the flag\n"
"when overwritten.\n"
"\n"
"So, we need to go deeper. How are variables actually represented?\n"
"Well, (local) variables are represented on something called a stack.\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"What is a stack? (Skip this if you know what a stack is)\n"
"A stack is an abstract data type (ADT), which allows two operations:\n"
" - Push: pushes an element to the top of the stack\n"
" - Pop: removes (pops) the element at the top of the stack\n"
"\n"
"If you have ever tried 'Tower of Hanoi', that game is essentially 3 stacks,\n"
"with the rings being popped off of one stack and pushed onto another.\n"
"For example, say I had a stack with the push and pop operations. If I did\n"
"\n"
"push(3) push(2) print(pop()) push(1)\n"
"\n"
"The operations would look like this,\n"
"push(3)\n"
"+------------------------------\n"
"|3|\n"
"+------------------------------\n"
"\n"
"push(2)\n"
"+------------------------------\n"
"|3|2|\n"
"+------------------------------\n"
"\n"
"print(pop()) // 2 \n"
"+------------------------------\n"
"|3|\n"
"+------------------------------\n"
"\n"
"push(1)\n"
"+------------------------------\n"
"|3|1|\n"
"+------------------------------\n"
"\n"
"Note that the stack can be applied to more than just numbers. Strings,\n"
"classes, and other ADTs can be used in place of numbers.\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Knowing what a stack is, let's consider how programs work.\n"
"If you were given a program, like\n"
"\n"
"int fun_3(){\n"
"    char whoareyou[32] = \"Stop getting so philosophical\";\n"
"    return 0x666;\n"
"}\n"
"int fun_2(){\n"
"    char whoami[16] = \"You are you\";\n"
"    fun_3();\n"
"    return 0x1337;\n"
"}\n"
"int fun_1(){\n"
"    int deadbeaf = 0xcafebaee;\n"
"    fun_2();\n"
"    return 0x1337;\n"
"}\n"
"int main(){\n"
"    int abc = 123;\n"
"    fun_1();\n"
"    return 0;\n"
"}\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"So, program repeatedly calls functions, but how does it know where to continue\n"
"when a function call returns? Introducing the stack! We can remember where to\n"
"jump back to by writing a small note of where we left off. In other words,\n"
"when we call a function, we push where to jump back to on the stack, and when\n"
"we return we pop the value off the stack and jump there. So if I take the\n"
"code above and add some markings,\n"
"\n"
"int fun_3(){\n"
"    char whoareyou[32] = \"Stop getting so philosophical\";\n"
"    return 0x666;\n"
"}\n"
"int fun_2(){\n"
"    char whoami[16] = \"You are you\";\n"
"    fun_3();\n"
"    if(whoami[0] == 'M'){                  // if_statement\n"
"        puts(\"Me\");\n"
"    }else{\n"
"        puts(\"Not me\");\n"
"    }\n"
"    return 0x1337;\n"
"}\n"
"int fun_1(){\n"
"    int deadbeaf = 0xcafebaee;\n"
"    fun_2();\n"
"    puts(\"Finished calling fun_2\");      // print_call\n"
"    return 0x1337;\n"
"}\n"
"int main(){\n"
"    int abc = 123;\n"
"    fun_1();\n"
"    return 0;                              // after_fun_1\n"
"}\n"
"\n"
"We see the following happens:\n"
"call fun_1()  // jump to after_fun_1 on return\n"
"+----------------------------------------\n"
"|after_fun_1|\n"
"+----------------------------------------\n"
"\n"
"call fun_2()  // jump to print_call on return\n"
"+----------------------------------------\n"
"|after_fun_1|print_call|\n"
"+----------------------------------------\n"
"\n"
"call fun_3()  // jump to if_statement on return\n"
"+----------------------------------------\n"
"|after_fun_1|print_call|if_statement|\n"
"+----------------------------------------\n"
"\n"
"fun_3 returns  // jump to value at top of stack\n"
"+----------------------------------------\n"
"|after_fun_1|print_call|\n"
"+----------------------------------------\n"
"\n"
"fun_2 returns  // jump to value at top of stack\n"
"+----------------------------------------\n"
"|after_fun_1|\n"
"+----------------------------------------\n"
"\n"
"fun_1 returns  // jump to value at top of stack\n"
"+----------------------------------------\n"
"|\n"
"+----------------------------------------\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Now, how are (local) variables stored? Well, they're stored in the stack as\n"
"well. It usually follow the pattern of\n"
"\n"
"|            |\n"
"|            |\n"
"|============|\n"
"|    ...     |\n"
"| Variables  |\n"
"|    ...     |\n"
"|------------|\n"
"| Return Ptr |\n"
"|============|\n"
"|    ...     |\n"
"| Variables  |\n"
"|    ...     |\n"
"|------------|\n"
"| Return Ptr |\n"
"|============|\n"
"|    ...     |\n"
"+------------+\n"
"\n"
"On the stack, we see local variables and the return pointer bunched together.\n"
"This is called a stack frame. As a point of detail, the stack is able to hold\n"
"8 bytes for each cell\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Now, onto the buffer overflow. This time instead of thinking about 'how to\n"
"overwrite is_admin', we should be thinking about 'how do we overwrite the\n"
"return pointer?' Well, going back to our memory representation, we see it\n"
"some like this:\n"
"\n"
"|        |\n"
"|--------|\n"
"|????????|  <- name\n"
"|????????|\n"
"|????????|\n"
"|????????|\n"
"|--------|\n"
"|00000000|  <- is_admin\n"
"|--------|\n"
"|????????|  <- Return Pointer\n"
"|========|\n"
"|   ...  |\n"
"+--------+\n"
"\n"
"There is actually something else on this stack called a base pointer, but\n"
"this is already a long enough tutorial. The memory actually looks something\n"
"this:\n"
"\n"
"|        |\n"
"|--------|\n"
"|????????|  <- name\n"
"|????????|\n"
"|????????|\n"
"|????????|\n"
"|--------|\n"
"|0000????|  <- is_admin (4 bytes long + endianness)\n"
"|--------|\n"
"|????????|  <- Stack Padding\n"
"|--------|\n"
"|????????|  <- Base Pointer\n"
"|--------|\n"
"|????????|  <- Return Pointer\n"
"|========|\n"
"|   ...  |\n"
"+--------+\n"
"\n"
"Press enter to continue...\n"
);
getc(stdin);
puts(
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"
"Now, using our buffer overflow in gets, if I were to input 'ABC', the memory\n"
"will look like\n"
"\n"
"|        |\n"
"|--------|\n"
"|?????CBA|  <- name\n"
"|????????|\n"
"|????????|\n"
"|????????|\n"
"|--------|\n"
"|0000????|  <- is_admin (4 bytes long + endianness)\n"
"|--------|\n"
"|????????|  <- Stack Padding\n"
"|--------|\n"
"|????????|  <- Base Pointer\n"
"|--------|\n"
"|????????|  <- Return Pointer\n"
"|========|\n"
"|   ...  |\n"
"+--------+\n"
"\n"
"Note this might look backwards. This is called little endian, where the\n"
"first character of the input will start from the right. Big endian would\n"
"start from the right. Knowing this, If I input\n"
"'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMN', we see:\n"
"\n"
"|        |\n"
"|--------|\n"
"|HGFEDCBA|  <- name\n"
"|PONMLKJI|\n"
"|XWVUTSRQ|\n"
"|FEDCBAZY|\n"
"|--------|\n"
"|MNLKJIHG|  <- is_admin (4 bytes long + endianness)\n"
"|--------|\n"
"|VUTSRQPO|  <- Stack Padding\n"
"|--------|\n"
"|DCBAZYXW|  <- Base Pointer\n"
"|--------|\n"
"|LKJIHGFE|  <- Return Pointer\n"
"|========|\n"
"|   ...  |\n"
"+--------+\n"
"\n"
"We overwrote the return pointer! And we know exactly what we overwrote it\n"
"with! Now, what if we overwrite the return pointer with something useful?\n"
"Perhaps, the print_flag function? Using a command like objdump, we can\n"
"disassemble the binary and read the assembly. Running\n"
"`objdump -d -M intel babyret2win` we see it has\n"
"\n"
"00000000004011d6 <print_flag>:\n"
"  4011d6:       f3 0f 1e fa             endbr64\n"
"  4011da:       55                      push   rbp\n"
"  4011db:       48 89 e5                mov    rbp,rsp\n"
"  4011de:       48 81 ec 10 01 00 00    sub    rsp,0x110\n"
"  4011e5:       48 8d 05 1c 0e 00 00    lea    rax,[rip+0xe1c]        # 402008 <_IO_stdin_used+0x8>\n"
"  4011ec:       48 89 c6                mov    rsi,rax\n"
"  4011ef:       48 8d 05 14 0e 00 00    lea    rax,[rip+0xe14]        # 40200a <_IO_stdin_used+0xa>\n"
"  4011f6:       48 89 c7                mov    rdi,rax\n"
"  4011f9:       e8 d2 fe ff ff          call   4010d0 <fopen@plt>\n"
"  4011fe:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n"
"  401202:       48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]\n"
"  401206:       48 8d 85 f0 fe ff ff    lea    rax,[rbp-0x110]\n"
"  40120d:       be 00 01 00 00          mov    esi,0x100\n"
"  401212:       48 89 c7                mov    rdi,rax\n"
"  401215:       e8 86 fe ff ff          call   4010a0 <fgets@plt>\n"
"  40121a:       48 8d 85 f0 fe ff ff    lea    rax,[rbp-0x110]\n"
"  401221:       48 89 c7                mov    rdi,rax\n"
"  401224:       e8 67 fe ff ff          call   401090 <puts@plt>\n"
"  401229:       90                      nop\n"
"  40122a:       c9                      leave\n"
"  40122b:       c3                      ret\n"
"\n"
"Here is the address of the print_flag function! 0x4011d6! If we jump\n"
"to this address, it will print the flag! (Note your binary may have a\n"
"different offset)\n"
"\n"
"Keeping in mind about little endian, we input\n"
"'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCD\\xd6\\x11\\x40\\x00\\x00\\x00\\x00\\x00'\n"
"The memory will look like\n"
"\n"
"|        |\n"
"|--------|\n"
"|HGFEDCBA|  <- name\n"
"|PONMLKJI|\n"
"|XWVUTSRQ|\n"
"|FEDCBAZY|\n"
"|--------|\n"
"|MNLKJIHG|  <- is_admin (4 bytes long + endianness)\n"
"|--------|\n"
"|VUTSRQPO|  <- Stack Padding\n"
"|--------|\n"
"|DCBAZYXW|  <- Base Pointer\n"
"|--------|\n"
"|\\x00\\x00\\x00\\x00\\x00\\x40\\x11\\xd6|  <- Return Pointer (print_flag)\n"
"|========|\n"
"|   ...  |\n"
"+--------+\n"
"\n"
"We overwrote the return pointer to print_flag and we have gotten our flag!\n"
"\n"
"Are you ready to try it on your own?\n"
"Press enter to continue...\n"
);
getc(stdin);

    int is_admin=0;
    char name[0x20];
    puts("What is your name?");
    gets(name);
    if(is_admin){
        puts("Hi admin!");
        // print_flag(); nope!
    }else{
        puts("You're not the admin!");
    }
}
